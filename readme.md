## dobEngin
Движок, чья первая версия была создана за день до дня рождения автора, который весит меньше 25 кб в текушей версии и 6.28 кб в версии 0.2, а в версии 0.5 9.75 кб в официальной минифицированной...<br>
Лицензия: [MIT](LICENSE)
## Быстрый старт
 1. Подключите движок к вашей html странице:  
    `<script src="dobengin.js"></script>` или `<script src="dobengin.min.js"></script>` для минифицированной версии (нужно чтоб файл был на сервере,а также последнию версию можно брать сразу с github через https://raw.githubusercontent.com/Dobrofiner/dobEngin/refs/heads/main/dobengin.js или https://raw.githubusercontent.com/Dobrofiner/dobEngin/refs/heads/main/dobengin.min.js)
 2. И затем добавьте ваш код через `<script></script>` или `<script src="/path/to/your/script.js"></script>`
 3. И кстати....движок сам себя не запустит полностью... и есть определенный порядок инита движка:
```js
const game = new dobEngin(true,"myCanvas")//Будет использовать ваш canvas с id myCanvas. Если убрать то как и на пррошлой версии создаст свой. Но с 0.5.0 применит стили заданные в .config и создаст его... Но неприменит если вы задали свой;
game.start();
game.assets = ["./path/to/your/assetsInPng"];
game.placeAssetsImgs();
game.gameLoop = ()=>{
    //Ваш код для gameLoop
};
game.startGameLoop();
//Далее идет то что вы хотите...
  ```
## Api, и т.д..
### Инициализация движка и базовые(и важные методы)
1. const YourObjectName = new dobEngin; <br>
Создание объекта движка. <br>
2. .start()  <br>
Инитиализация canvas и drw объекта. <br>
3. .placeAssetsImgs() <br>
Берет пути к ассетам из массива assets и создает img объекты и пихает их в объект assetsForUse <br>
4. .startGameLoop() <br>
Запуск gameLoop'а. без этого рисовка графики работать не будет <br>
5. .gameLoop() <br>
Можно переопределять. здесь ваш собственный код для игрового цикла
### Переменные и объекты,массивы 
6. .fps <br>
Значение которое содержит фпс счетчик....с приколами. А ещё при старте задает ограничение по фпс.. <br>
7. .width, .height <br>
Содержат ширину и высоту canvas'а....можно менять <br>
8. .objects - массив хранящий все инстансы объектов <br>
9. .objectTypes - объект,хранящий созданные типы объектов <br>
10. .animations - объект, хранящий глобальные массивы анимаций <br>
11. .nextDuid - содержит следующее значения duid, уникальных id объектов.<br>
12. .config - пока что содержит только значения для настройки страницы,div'а а также канваса игры. по умолчанию:<br>
    {<br>
  canvasColor:"#fff",<br>
  bodyColor:"#000",<br>
  physicalCanvasHeight:'100%',<br>
  physicalCanvasWidth:"100%",<br>
  physGameDivHeight:'95vh',<br>
  physGameDivWidth:'75%',<br>
  bodyJustifyContentType:"center",<br>
  bodyDisplay:"flex"<br>
    } что является режимом: растянуть по плошади данной без  сохранения пропорций<br>
13. physicalScaleX,physicalScaleY - содержат масштаб-соотношение буфера игры к физическим размерам<br>
14. mouse - объект мышки содержащий: {<br>
  x- x мышки в мире игры,<br>
  y- y мышки в мире игры,<br>
  realX,realY - x,y что реальные по отношению к окну браузера.<br>
}<br>
15. curLevel. хранит данные текучего уровня. по умолчанию:<br>
        curLevel = {<br>
            width:640,<br>
            height:480 - ограничивает карту на 640x480 пкикселей...<br>
        }<br>
но так поддерживает:<br>
isInfinite - true/false. бесконечен ли уровень...если да то прокручивается максимум до максимаольно возможного числа<br>
и т.д уровней, но это уже отдельный раздел.<br>
### Работа с объектами
16. .createObjectType(type,name,...properties) <br>
где type - тип объекта(sprite/text),name- конечно имя объекта <br>
...properties содержит параметры  в порядке - name,x,y, и spriteImage если это спрайт и text если это text объект <br>
17. .spawnObject(type,...properties)=> obj <br>
создает объект,с типом из type(из objectTypes),с свойствами(name,x,y,[[text||spriteImage]]), и затем возвращает его <br>
18. destroyObject(dUid) => удаленный объект <br>
удаляет объект по dUid. и он навсегда исчезает из игры. <br>
## Утилиты
19. downloadString(string,mime,name) => string <br>
возврашает строку вида data:text/plain,string а также скачивает её с установленным именем файла(и расширинием и mime). работает даже в file:// <br>
20. .dUid() => number <br>
возврашает текучий dUid и затем его повышает на 1. Система уникальных UID порядкового типа этого движка. dUid расшифровывается как Dobrofiner UID system <br>
21. addAnim(arr,name,isGif=false) <br>
arr - массив имен кадров, если есть берутся из assetsForUse <br>
name - имя. Если опустить то будет сгенертровано рандомное,вида 1.15 <br>
isGif - по умолчанию false. Было добавлно для gif анимаций но они не поддерживаются.<br> 
Добавляет анимацию в глобальный для движка объект содержащий анимации, .animations. Только для спрайтов <br>
22. isArr(arr) => true|false <br>
Проверяет, является ли вводимый элемент массивом,используя прикол с try catch<br>
### Рендеринг
23. .drw - используется для рисования графики на канвасе движка.(Canvas2dRenderingContext)<br>
24. setCameraCoords(x,y) - задает координаты для камеры,нужно чтобобъект слежения, например игрок был отупшен
25.  mouseToCanvasXY(mousX,mousY) - конвертирует физическое местоположение клика/чего либо заданного в параметрах mousX,mousY в [ x,y ] по местоположению камеры в мире
26.  normalizeCoordsWithScale(x,y) - преобразует физические x,y в внутриигровые по масштfбу который вычисляетя каждый кадр, через функцию updateScales()
27. renderCamera(objectFollow) - рендерит объекты и объект слежняи по центру экрана,отсекая все невидимое.
28. camera - объект камеры.содержимое: <br>
{<br>
  x:x положение камеры,<br>
  y:y положение камеры,<br>
  height:высота камеры,<br>
  width: ширина камеры,<br>
 follow: объект следования. пока что значения не имеет в самом движке<br>
}<br>
### Управление движком
 29. setFps(fps) - меняет макс фпс на целовой.после несколько применений может багануться <br>
 30. stop() - останавливает gameLoop игры <br>
 31. resume() - продолжает gameLoop игры <br>
### Классы
32. Класс sprite(properties,engine) <br>
класс спрайта. основной класс для создания объектов. содержит: <br>
.dUid - всегда 0,если тип объекта не был создан как объект... <br>
.props содержит <br>
{ <br>
name  - имя объекта <br>
x - координата x на сетке <br>
y - координата y на сетке <br>
spriteImage - содержит ссылку на спрайт объекта <br>
width - размер по длине в пикселях объекта<br>
height - размер по высоте в px объекта<br>
animations - объект анимаций, связанных с объектом...<br>
} <br>
.defProps - дефолтные значения объекта. наследуются от типа с которого был создан<br>
.objectType  - имя типа объекта, с которого был создан экземпляр<br>
.type - всегда "sprite" <br>
.getSprite(spr) => string (assetsForUse[spr]) || Object  <br>
Возвращает либо объект с спрайтом либо spr подставленный в объект храняший загруженные спрайты <br>
.getAnimByName(anim) - получает анимацию из реестра анимаций и связываетс объектом <br>
.curAnim - состояние анимации, включащее:<br>
  {<br>
    animName: имя анимации,<br>
    curFrame: текучий кадр, <br>
    state:состояние,  <br>
    speed:5 в кадрах в секунду,<br>
    cycle:повторяется ли анимация?<br>
  }<br>
  .play(name,speed=5,start=0,cycle=true,isGif=false) - проигрывает анимацию,взятую из props.animations со скоростью равным speed что является фпс анимации. по умолчанию 5.<br>
  start указывает на кадр с которого стоит начать, оно не должно превышать длину анимации. <br>
  если cycle = true (по умолчанию так) то работает анимация бесконечно.. <br>
  .stop - останавливает текучую анимацию и сбрасывает кадры до нуля, через clearInterval<br>
  .pause - останавливает анимацию, но кадр остается и анимацию можно продолжить.<br>
  .resume - продолжает цикл анимации, вызывая play с start=curFrame..<br>
.setProps(..props) <br>
 устанавливает свойства,но обновляет только те значения порядкорве которых не равны undefined/null и т.д {УДАЛЕНО С 0.5.0}<br>
33. Класс text <br>
класс текста. основной класс для создания объектов. содержит: <br>
.dUid - тоже самое что и с sprite <br>
.props содержит <br>
{ <br>
name  - имя объекта <br>
x - координата x на сетке <br>
y - координата y на сетке <br>
text - текст который он будет отображать <br>
} <br>
.defProps - дефолтные значения объекта. наследуются от типа с которого был создан <br>
.objectType  - имя типа объекта, с которого был создан экземпляр <br>
.type - всегда "text" <br>
this.isCreated - создан ли объект? true || false <br>   
.setProps(..props) <br>
 тоже самое что и с sprite {УДАЛЕНО С 0.5.0} <br>
.typewriter(text,length=0)=> эффект печатной машинки.<br>
выводит текст посимвольно,динамимчески вычисляя время на вывод символа.очищает текучее если было запущено другое.<br>
если length = 0;то выводится сразу же, без эффекта<br>
34. класс levelLoader(engine). по умолчанию,движок создает готовый объект: lvlLoader готовый к использованию.<br>
engine - ссылка на движок,необходимая для того чтоб движок этот был доступеен объекту<br>
.loadlevel(url) - загружает уровень через xmlhttprequest и при удачной загрузки записывает его в .curLevel, и запускает парсинг<br>
.parseLevel() - проверяет что это именно lvl этого движка через специальную переменную и есдли да,то устанавливает переменные некоторые и создает  объекты из раздела .objects<br>
.spawnObj(type,propsObj)<br>
обертка вокруг spawnObject, которая также более безопасна и использщуется при парсинге объектов...<br>
поддерживает изображения по имени а также названия анимаций по имени<br>
.getSprite() - получает спрайт по имени из engine.spritesForUse<br>
## Шаблон для сцен/уровней движка (не играбельный уровень)
Можно найти в файле [testLevel.json](testLevel.json)
## Пример кода
Посмотреть можно в файле [game.js](game.js) <br>